{"version":3,"sources":["../../src/queryProcessor.js"],"names":["QueryProcessor","q","backendSrv","variables","capabilities","url","headers","typeResources","numericMapping","point","value","timestamp","availMapping","target","options","then","postData","start","range","from","valueOf","end","to","order","multipleMetrics","id","metricIds","resolve","caps","QUERY_POST_ENDPOINTS","seriesAggFn","ids","rawQuery","timeAggFn","singleStatLiveQuery","limit","metrics","singleStatQuery","rawQueryLegacy","TAGS_QUERY_LANGUAGE","tagsQL","undefined","length","tags","resolveToString","when","uri","type","rate","join","datasourceRequest","data","method","processRawResponse","response","status","all","map","encodeURIComponent","metric","replace","params","processRawResponseLegacy","refId","timeSerie","datapoints","sortedData","sort","p1","p2","_","chain","zip","slice","filter","pair","point1","point2","value_diff","time_diff","fnBucket","bucket","avg","min","max","buckets","stacked","processSingleStatResponse","Date","now","processSingleStatLiveResponse","reduceFunc","presentValues","reduce","a","b","latestPoints","timeSeries","dp"],"mappings":"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","file":"queryProcessor.js","sourcesContent":["import {modelToString as tagsModelToString} from './tagsKVPairsController';\n\nexport class QueryProcessor {\n\n  constructor(q, backendSrv, variables, capabilities, url, headers, typeResources) {\n    this.q = q;\n    this.backendSrv = backendSrv;\n    this.variables = variables;\n    this.capabilities = capabilities;\n    this.url = url;\n    this.headers = headers;\n    this.typeResources = typeResources;\n    this.numericMapping = point => [point.value, point.timestamp];\n    this.availMapping = point => [point.value == 'up' ? 1 : 0, point.timestamp];\n  }\n\n  run(target, options) {\n    return this.capabilities.then(caps => {\n      let postData = {\n        start: options.range.from.valueOf(),\n        end: options.range.to.valueOf(),\n        order: 'ASC'\n      };\n      let multipleMetrics = true;\n      if (target.id) {\n        const metricIds = this.variables.resolve(target.id, options);\n        if (caps.QUERY_POST_ENDPOINTS) {\n          if (!target.seriesAggFn || target.seriesAggFn === 'none') {\n            postData.ids = metricIds;\n            return this.rawQuery(target, postData);\n          } else if (target.timeAggFn == 'live') {\n            // Need to change postData\n            return this.singleStatLiveQuery(target, {ids: metricIds, limit: 1});\n          } else {\n            // Need to perform multiple series aggregation\n            postData.metrics = metricIds;\n            return this.singleStatQuery(target, postData);\n          }\n        } else {\n          return this.rawQueryLegacy(target, options.range, metricIds);\n        }\n      } else {\n        if (caps.TAGS_QUERY_LANGUAGE) {\n          if (target.tagsQL !== undefined && target.tagsQL.length > 0) {\n            postData.tags = this.variables.resolveToString(target.tagsQL, options);\n          } else {\n            return this.q.when([]);\n          }\n        } else {\n          if (target.tags !== undefined && target.tags.length > 0) {\n            postData.tags = tagsModelToString(target.tags, this.variables, options);\n          } else {\n            return this.q.when([]);\n          }\n        }\n        if (!target.seriesAggFn || target.seriesAggFn === 'none') {\n          return this.rawQuery(target, postData);\n        } else if (target.timeAggFn == 'live') {\n          // Need to change postData\n          return this.singleStatLiveQuery(target, {tags: postData.tags, limit: 1});\n        } else {\n          // Need to perform multiple series aggregation\n          return this.singleStatQuery(target, postData);\n        }\n      }\n    });\n  }\n\n  rawQuery(target, postData) {\n    const uri = [\n      this.typeResources[target.type],   // gauges or counters\n      target.rate ? 'rate' : 'raw', // raw or rate\n      'query'\n    ];\n    const url = this.url + '/' + uri.join('/');\n\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processRawResponse(target, response.status == 200 ? response.data : []));\n  }\n\n  rawQueryLegacy(target, range, metricIds) {\n    return this.q.all(metricIds.map(metric => {\n      const uri = [\n        this.typeResources[target.type],  // gauges, counters or availability\n        encodeURIComponent(metric).replace('+', '%20'), // metric name\n        'data'];\n      const url = this.url + '/' + uri.join('/');\n\n      return this.backendSrv.datasourceRequest({\n        url: url,\n        params: {\n          start: range.from.valueOf(),\n          end: range.to.valueOf()\n        },\n        method: 'GET',\n        headers: this.headers\n      }).then(response => this.processRawResponseLegacy(target, metric, response.status == 200 ? response.data : []));\n    }));\n  }\n\n  processRawResponse(target, data) {\n    return data.map(timeSerie => {\n      return {\n        refId: target.refId,\n        target: timeSerie.id,\n        datapoints: timeSerie.data.map(target.type == 'availability' ? this.availMapping : this.numericMapping)\n      };\n    });\n  }\n\n  processRawResponseLegacy(target, metric, data) {\n    let datapoints;\n    if (target.type == 'availability') {\n      datapoints = data.map(this.availMapping);\n    } else if (!target.rate) {\n      datapoints = data.map(this.numericMapping);\n    } else {\n      let sortedData = data.sort((p1, p2)=> p1.timestamp - p2.timestamp);\n      datapoints = _.chain(sortedData)\n        .zip(sortedData.slice(1))\n        .filter(pair => {\n          return pair[1] // Exclude the last pair\n            && (target.type != 'counter' || pair[0].value <= pair[1].value); // Exclude counter resets\n        })\n        .map(pair => {\n          let point1 = pair[0], point2 = pair[1];\n          let timestamp = point2.timestamp;\n          let value_diff = point2.value - point1.value;\n          let time_diff = point2.timestamp - point1.timestamp;\n          let rate = 60000 * value_diff / time_diff;\n          return [rate, timestamp];\n        })\n        .value();\n    }\n    return {\n      refId: target.refId,\n      target: metric,\n      datapoints: datapoints\n    };\n  }\n\n  singleStatQuery(target, postData) {\n    // Query for singlestat => we just ask for a single bucket\n    // But because of that we need to override Grafana behaviour, and manage ourselves the min/max/avg/etc. selection\n    let fnBucket;\n    if (target.timeAggFn == 'avg') {\n      fnBucket = bucket => bucket.avg;\n    } else if (target.timeAggFn == 'min') {\n      fnBucket = bucket => bucket.min;\n    } else if (target.timeAggFn == 'max') {\n      fnBucket = bucket => bucket.max;\n    } // no else case. \"live\" case was handled before\n    const url = this.url + '/' + this.typeResources[target.type] + '/stats/query';\n    delete postData.order;\n    postData.buckets = 1;\n    postData.stacked = target.seriesAggFn === 'sum';\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processSingleStatResponse(target, fnBucket, response.status == 200 ? response.data : []));\n  }\n\n  processSingleStatResponse(target, fnBucket, data) {\n    return data.map(bucket => {\n      return {\n        refId: target.refId,\n        target: \"Aggregate\",\n        datapoints: [[fnBucket(bucket), bucket.start]]\n      };\n    });\n  }\n\n  singleStatLiveQuery(target, postData) {\n    const uri = [\n      this.typeResources[target.type], // gauges, counters or availability\n      target.rate ? 'rate' : 'raw', // raw or rate\n      'query'\n    ];\n    const url = this.url + '/' + uri.join('/');\n    // Set start to now - 5m\n    postData.start = Date.now() - 300000;\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processSingleStatLiveResponse(target, response.status == 200 ? response.data : []));\n  }\n\n  processSingleStatLiveResponse(target, data) {\n    let reduceFunc;\n    if (target.seriesAggFn === 'sum') {\n      reduceFunc = (presentValues => presentValues.reduce((a,b) => a+b));\n    } else {\n      reduceFunc = (presentValues => presentValues.reduce((a,b) => a+b) / presentValues.length);\n    }\n    let datapoints;\n    const latestPoints = data.filter(timeSeries => timeSeries.data.length > 0)\n        .map(timeSeries => timeSeries.data[0]);\n    if (latestPoints.length === 0) {\n      datapoints = [];\n    } else {\n      datapoints = [[reduceFunc(latestPoints.map(dp => dp.value)), latestPoints[0].timestamp]];\n    }\n    return [{\n      refId: target.refId,\n      target: \"Aggregate\",\n      datapoints: datapoints\n    }];\n  }\n}\n"]}